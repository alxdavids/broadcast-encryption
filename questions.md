# Open questions

## Q1

> The scenario explained above requires a trusted central entity, and the decryption is always meant for this trusted entity and a single other party. What other simpler ways can you think of to design such a scheme?

The public keys (`P_i` values) of the advertisers could be stored at the central entity and only download `P_{n-1}` for computing `K`. When the client needs to encrypt a value to a given advertiser `j`, it could just download the value `P_{n - (j+1)}` from the trusted entity that it needs to compute `C1` in `Hdr`.

> What other simpler ways can you think of to design such a scheme? Are there any other encryption schemes that would be more efficient (bandwidth and computation) than broadcast encryption? What are the pros and cons of the different options?

A naive scheme that encrypts the same message to the public key of the trusted entity and the public key of the targeted advertiser should be possible. The public keys would have to be made available in some trusted registry, similar to a PKI. 

The advantages of such a scheme are that you would not have to use pairings which have a non-negligible efficiency burden compared to standard public-key encryption. Improving further, the client could establish secure channels between itself (using hybrid public key encryption, as in TLS) and the advertisers/the trusted entity, so that the actual encryption of data is done symmetrically. 

The cons of such an approach include that it requires an established PKI in order to manage advertiser public keys. Moreover, it would require two encryption operations as opposed to one in the broadcast case. However, these encryptions should be computationally much more efficient.

## Q2

> The paper in this exercise focused is based on a paper by Dan Boneh, Craig Gentry and Brent Waters that leverages symmetric pairings to implement the broadcast encryption channel. Can you think of reasons to prefer one implementation over the other for a production system?

Symmetric pairings require using supersingular elliptic curves, while asymmetric pairings can be built on top of ordinary curves. As noted in the Dubois et al. paper, using such curves comes with a practical cost in terms of computation and communication.

## Q3

> Imagine you have to take the MVP code above to production. What are the concrete steps youâ€™d take?

- Use an audited implementation of a BLS curve for performing the broadcast encryption scheme. I used bn256 in this exercise, but the security level of this curve is below 128 bits. BLS curves at higher parameter settings perform more efficiently than BN curves, and so they would make a more natural choice. Moreover, the implementation would have to support constant-time operations, so that time-based side-channel attacks on the client ciphertexts could not be launched by malicious advertisers.
- Publish the source of the encryption scheme as a library so that it could be used in server- and client-side implementations separately. The library would include documentation for the public functionality (`Setup`, `Encrypt`, `Decrypt`).
- Build test vectors for the implementation to check that the crypto operations are correct. The test vectors would be initially generated by a proof-of-concept implementation of the scheme in sagemath. I find it useful to do it this way because sagemath provides a more natural interface between the scheme as written and the code.
- Build an automated continuous integration pipeline that would run tests on the implementation whenever a change was pushed. When a new release was tagged, a separate pipeline would run all necessary checks and then publish the package for use elsewhere.